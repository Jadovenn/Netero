/**
 * Netero sources under BSD-3-Clause
 * see LICENSE.txt
 */

#include <algorithm>

#include "SpvToH.hpp"

std::string ToUpper(const std::string& aString)
{
    std::string upperCaseString;

    for (const char c : aString) {
        upperCaseString += std::toupper(c);
    }
    return upperCaseString;
}

namespace SpvToH {

void PrintNeteroHeader(std::ofstream& aFile)
{
    aFile << "/**" << std::endl;
    aFile << " * Netero sources under BSD-3-Clause" << std::endl;
    aFile << " * see LICENSE.txt" << std::endl;
    aFile << " *" << std::endl;
    aFile << " * Autogenerated file by SpvToH, DO NOT EDIT!" << std::endl;
    aFile << " */" << std::endl;
    aFile << std::endl;
}

void PrintHeaderGuardPrefix(std::ofstream& aFile, const std::string& aName)
{
    auto capitalizedName = ToUpper(aName);

    aFile << "#ifndef " << capitalizedName << "_H_" << std::endl;
    aFile << "# define " << capitalizedName << "_H_" << std::endl;
    aFile << "" << std::endl;
    aFile << "# ifdef __cplusplus" << std::endl;
    aFile << "extern \"C\" {" << std::endl;
    aFile << "# endif // __cplusplus" << std::endl;
    aFile << "" << std::endl;
}

void PrintHeaderGuardSuffix(std::ofstream& aFile, const std::string& aName)
{
    auto capitalizedName = ToUpper(aName);

    aFile << "# ifdef __cplusplus" << std::endl;
    aFile << "}" << std::endl;
    aFile << "# endif // __cplusplus" << std::endl;
    aFile << "" << std::endl;
    aFile << "#endif // " << capitalizedName << "_H_" << std::endl;
    aFile << "" << std::endl;
}

std::string ExtractFileNameWithoutExtension(const std::string& aFilePath)
{
    auto nameEnd = aFilePath.rfind(".h");
    auto nameBegin = aFilePath.find_last_of('/');
    if (nameBegin == std::string::npos) {
        nameBegin = 0;
    }
    else {
        nameBegin += 1;
    }
    return aFilePath.substr(nameBegin, nameEnd - nameBegin);
}

void ExtractFileDataAsChar(std::ifstream& aFile, std::vector<char>& someDataOut)
{
    const size_t size = aFile.tellg();
    someDataOut.reserve(size);
    aFile.seekg(0);
    aFile.read(someDataOut.data(), size);
}

unsigned ExtractArrayCount(std::vector<char>& someData)
{
    unsigned count = 0;
    for (char* c = someData.data(); c != someData.data() + someData.capacity(); ++c) {
        if (*c == 'x') {
            count += 1;
        }
    }
    return count;
}

void EmitSymbols(std::ofstream& aFile, const std::string& aSymbolSuffix, std::vector<char>& someData, unsigned aWordCount) {
    aFile << "const unsigned    " << aSymbolSuffix << "WordCount = " << aWordCount << ";" << std::endl;
    aFile << std::endl;
    aFile << "const unsigned    " << aSymbolSuffix << "Data [" << aWordCount << "] = {" << std::endl;
    aFile << "    ";
    for (char* c = someData.data(); c != someData.data() + someData.capacity(); ++c) {
        if (*c == '}' || *c == '{') {
            continue;
        }
        aFile << *c;
        if (*c == '\n' && c + 1 != someData.data() + someData.capacity()) {
            aFile << "    ";
        }
    }
    aFile << "};" << std::endl;
    aFile << std::endl;
}

} // namespace SpvToH
